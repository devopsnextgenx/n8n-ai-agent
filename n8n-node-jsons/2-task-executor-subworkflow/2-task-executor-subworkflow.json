{
  "name": "task-executor-subworkflow",
  "nodes": [
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"task_description\": {\"type\": \"string\"},\n    \"params\": {\"type\": \"object\"},\n    \"task_tool\": {\"type\": \"string\"},\n    \"task_output\": {\"type\": \"object\"},\n    \"task_status\": {\"type\": \"string\", \"enum\": [\"success\", \"failure\"]},\n    \"task_id\": {\"type\": \"string\"}\n  },\n  \"required\": [\"task_description\", \"params\", \"task_tool\", \"task_output\", \"task_status\", \"task_id\"]\n}"
      },
      "id": "d971e96f-ca41-4956-9046-0d6910004140",
      "name": "Task Result Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        864,
        704
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "endpointUrl": "http://host.docker.internal:6789/mcp",
        "serverTransport": "httpStreamable",
        "include": "except",
        "excludeTools": [
          "listTools"
        ],
        "options": {}
      },
      "id": "3619c93d-277b-4c70-af61-d8eddd93812c",
      "name": "MCP Available Tools Client",
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "position": [
        752,
        688
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract ready tasks and create individual items for processing\nconst data = $input.item.json;\nconst readyTasks = data.readyTasks || [];\n\nif (readyTasks.length === 0) {\n  // No ready tasks, return the original data for final processing\n  return data;\n}\n\n// Get the first ready task to process\nconst currentTask = readyTasks[0];\n\n// Return the task data along with the original registry information\nreturn {\n  ...currentTask,\n  originalData: data\n};"
      },
      "id": "af208209-3e67-4417-b797-6c3f571f12ae",
      "name": "Process Ready Task",
      "type": "n8n-nodes-base.code",
      "position": [
        624,
        208
      ],
      "typeVersion": 2
    },
    {
      "parameters": {},
      "id": "8fc57c6f-840f-4886-b620-28982f710b44",
      "name": "Merge Task Results",
      "type": "n8n-nodes-base.merge",
      "position": [
        1424,
        272
      ],
      "typeVersion": 3
    },
    {
      "parameters": {
        "jsCode": "// Update task registry with completed task result\nconst taskResult = $input.first().json.output || $input.first().json;\nconst executedTask = $input.last().json;\n\n// Get original task data\nconst originalData = executedTask.originalData;\n\n// Clone existing registry state\nconst taskRegistry = { ...originalData.taskRegistry };\nconst completedTasks = [...originalData.completedTasks];\nconst pendingTasks = [...originalData.pendingTasks];\n\n// Mark current task as completed\nif (taskRegistry[taskResult.task_id]) {\n  taskRegistry[taskResult.task_id].status = taskResult.task_status;\n  taskRegistry[taskResult.task_id].output = taskResult.task_output;\n  \n  if (taskResult.task_status === \"success\") {\n    if (!completedTasks.includes(taskResult.task_id)) {\n      completedTasks.push(taskResult.task_id);\n    }\n    const pendingIndex = pendingTasks.indexOf(taskResult.task_id);\n    if (pendingIndex > -1) {\n      pendingTasks.splice(pendingIndex, 1);\n    }\n  }\n}\n\n// Helper function to extract task ID from $ref path\nfunction extractTaskIdFromRef(ref, taskRegistry) {\n  // supports: \"#/tasks/0/results\" or \"#/tasks/task_1/results\"\n  const pathParts = ref.split(\"/\").filter(Boolean);\n  const taskIndex = pathParts.findIndex(p => p === \"tasks\");\n  \n  if (taskIndex !== -1 && pathParts.length > taskIndex + 1) {\n    const nextPart = pathParts[taskIndex + 1];\n    \n    // If it's a number, map index â†’ task_id from registry order\n    if (/^\\d+$/.test(nextPart)) {\n      const allTaskIds = Object.keys(taskRegistry);\n      return allTaskIds[parseInt(nextPart, 10)];\n    }\n    \n    return nextPart;\n  }\n  \n  return null;\n}\n\n// Helper function to extract value from nested path\nfunction getNestedValue(obj, path) {\n  // Handle paths like \"result.sum\" or \"data[0].value\"\n  if (!path) return obj;\n  \n  const parts = path.split(/[.\\[\\]]+/).filter(Boolean);\n  let current = obj;\n  \n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n    current = current[part];\n  }\n  \n  return current;\n}\n\n// Helper function to resolve $ref value from completed task\nfunction resolveRefValue(ref, taskRegistry) {\n  // Parse the ref path: \"#/tasks/0/results/sum\" or \"#/tasks/task_1/results\"\n  const pathParts = ref.split(\"/\").filter(Boolean);\n  const taskIndex = pathParts.findIndex(p => p === \"tasks\");\n  \n  if (taskIndex === -1 || pathParts.length <= taskIndex + 1) {\n    return null;\n  }\n  \n  // Extract task ID\n  const taskId = extractTaskIdFromRef(ref, taskRegistry);\n  if (!taskId || !taskRegistry[taskId]?.output) {\n    return null;\n  }\n  \n  const depOutput = taskRegistry[taskId].output;\n  \n  // Check if there's a nested path after \"results\"\n  const resultsIndex = pathParts.indexOf(\"results\");\n  if (resultsIndex !== -1 && pathParts.length > resultsIndex + 1) {\n    // Extract nested path: [\"sum\"] from \"#/tasks/0/results/sum\"\n    const nestedPath = pathParts.slice(resultsIndex + 1).join(\".\");\n    \n    // Try to extract from result field first, then from root\n    if (depOutput.result !== undefined) {\n      const nestedValue = getNestedValue(depOutput.result, nestedPath);\n      if (nestedValue !== undefined) {\n        return nestedValue;\n      }\n    }\n    \n    return getNestedValue(depOutput, nestedPath);\n  }\n  \n  // No nested path, return result or full output\n  return depOutput.result !== undefined ? depOutput.result : depOutput;\n}\n\n// Recursive function to resolve $ref in nested structures\nfunction resolveParamRefs(params, taskRegistry) {\n  if (params === null || params === undefined) {\n    return params;\n  }\n  \n  // Handle $ref object\n  if (typeof params === \"object\" && !Array.isArray(params) && \"$ref\" in params) {\n    return resolveRefValue(params.$ref, taskRegistry);\n  }\n  \n  // Handle array\n  if (Array.isArray(params)) {\n    return params.map(item => resolveParamRefs(item, taskRegistry));\n  }\n  \n  // Handle plain object\n  if (typeof params === \"object\") {\n    const resolved = {};\n    for (const [key, value] of Object.entries(params)) {\n      resolved[key] = resolveParamRefs(value, taskRegistry);\n    }\n    return resolved;\n  }\n  \n  // Return primitive values as-is\n  return params;\n}\n\n// Validate that all dependencies are successfully completed\nfunction canExecuteTask(task, taskRegistry, completedTasks) {\n  if (!task.dependencies || task.dependencies.length === 0) {\n    return true;\n  }\n  \n  return task.dependencies.every(depId => {\n    const isCompleted = completedTasks.includes(depId);\n    const isSuccessful = taskRegistry[depId]?.status === \"success\";\n    const hasOutput = taskRegistry[depId]?.output !== undefined;\n    \n    return isCompleted && isSuccessful && hasOutput;\n  });\n}\n\n// Find ready tasks (dependencies completed)\nconst readyTasks = [];\n\nfor (const taskId of pendingTasks) {\n  const task = taskRegistry[taskId];\n  \n  if (task.status === \"pending\" && canExecuteTask(task, taskRegistry, completedTasks)) {\n    // Deep clone task to avoid mutations\n    const enrichedTask = JSON.parse(JSON.stringify(task));\n    \n    // Recursively resolve all $ref references in params\n    enrichedTask.params = resolveParamRefs(enrichedTask.params, taskRegistry);\n    \n    readyTasks.push(enrichedTask);\n  }\n}\n\n// Return updated workflow state\nreturn {\n  taskRegistry,\n  pendingTasks,\n  completedTasks,\n  readyTasks,\n  currentBatch: (originalData.currentBatch || 0) + 1,\n  totalTasks: originalData.totalTasks,\n  lastTaskResult: taskResult\n};"
      },
      "id": "9a223a85-a6fb-4da2-bf69-472633775fae",
      "name": "Update Task Registry",
      "type": "n8n-nodes-base.code",
      "position": [
        1632,
        288
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 1,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "more-tasks-condition",
              "operator": {
                "type": "number",
                "operation": "gt"
              },
              "leftValue": "={{ $json.pendingTasks.length }}",
              "rightValue": 0
            }
          ]
        },
        "options": {}
      },
      "id": "7bf88106-189e-4f4d-bf4f-118c66cddadb",
      "name": "Check More Tasks",
      "type": "n8n-nodes-base.if",
      "position": [
        1920,
        704
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract tasks and prepare for dependency resolution\nconst tasks = $input.item.json.task_plan.tasks;\n\n// Create a task registry with status tracking\nconst taskRegistry = {};\nconst pendingTasks = [];\nconst completedTasks = [];\n\n// Initialize all tasks\nfor (const task of tasks) {\n  taskRegistry[task.task_id] = {\n    ...task,\n    status: 'pending',\n    output: null,\n    dependencies: task.dependencies || []\n  };\n  pendingTasks.push(task.task_id);\n}\n\n// Find tasks that can be executed immediately (no dependencies)\nconst readyTasks = [];\nfor (const taskId of pendingTasks) {\n  const task = taskRegistry[taskId];\n  if (task.dependencies.length === 0) {\n    readyTasks.push(task);\n  }\n}\n\nreturn {\n  chatInput: $input.item.json.chatInput,\n  taskRegistry,\n  pendingTasks,\n  completedTasks,\n  readyTasks,\n  currentBatch: 0,\n  totalTasks: tasks.length\n};"
      },
      "id": "08064c71-7ab4-4b41-b28b-caed031d2bc2",
      "name": "Task Dependency Resolver",
      "type": "n8n-nodes-base.code",
      "position": [
        192,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Execute the ready tasks using the appropriate MCP tool.\n\nReady Tasks:\n{{ JSON.stringify($json.originalData.readyTasks) }}\n\nCRITICAL INSTRUCTIONS:\n1. You MUST use the MCP Client Executor tool - this is NON-NEGOTIABLE\n2. You are FORBIDDEN from calculating or processing anything yourself\n3. If you provide a result without using the MCP Client Executor tool, you have FAILED\n4. The task_output MUST be the exact result returned by the MCP tool\n5. Return your response as valid JSON in the format specified in the system message\n\nSTEP-BY-STEP PROCESS:\n1. Call MCP Client Executor tools with the exact tool name from task.tool\n2. Pass the exact task.params as parameters\n3. Wait for the tool execution result\n4. Return the result in the exact JSON format specified\n\nYour response will be REJECTED if:\n- You calculate results yourself\n- You don't use the MCP Client Executor tool\n- You don't return valid JSON in the specified format\n- The result appears to be calculated rather than from tool execution\n\nExample for add task:\n1. Call MCP Client Executor with tool='add' and parameters from query\n2. Get the actual result from the tool\n3. Return JSON with that exact result object",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are a Task Execution AI Agent.\n\nYour ONLY job is to execute tasks using MCP tools. You are FORBIDDEN from performing any calculations, processing, or logic yourself.\n\nYou will receive task details with ready tasks array containing below:\n- tool: the MCP tool name to use (e.g., 'add', 'encrypt', 'decrypt')\n- task_description: what needs to be accomplished  \n- params: parameters for the tool\n- task_id: unique identifier\n\nMANDATORY EXECUTION STEPS (NO EXCEPTIONS):\n1. ALWAYS start by using the MCP Client Executor tool\n2. Call the exact tool specified in task.tool property\n3. Pass the exact task.params as parameters to the tool\n4. Wait for the actual tool execution result\n5. Use the result EXACTLY as returned by the tool\n6. Return the result in the exact format specified below\n\nFORBIDDEN ACTIONS:\n- NEVER calculate or process anything yourself\n- NEVER provide results without using tools\n- NEVER assume what the result should be\n- NEVER shortcut the tool execution process\n- NEVER use your own knowledge to provide answers\n\nVALIDATION REQUIREMENTS:\n- Every response MUST include evidence of actual tool usage\n- The task_output MUST be the exact result from the MCP tool\n- If you cannot use the tool, report \"failure\" status with error details\n\nRETURN FORMAT (MUST be valid JSON):\n{\n  \"task_description\": \"copy original task_description\",\n  \"params\": {},\n  \"task_tool\": \"tool name that was used\",\n  \"task_output\": {},\n  \"task_status\": \"success\",\n  \"task_id\": \"copy original task_id\"\n}\n\nCRITICAL: You MUST return valid JSON in the exact format above. Do not use any other formatting.\n\nREMEMBER: \n- If you provide any result without actually using the MCP Client Executor tool, you have FAILED your purpose.\n- Only Return valid JSON Response"
        }
      },
      "id": "34b19f4f-645b-4774-93d8-d0e84296e9f0",
      "name": "Task Executor Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        656,
        496
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {},
      "id": "2ad7118e-0dbd-4fc8-9e7e-f151eb68194f",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "position": [
        2368,
        16
      ],
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "jsCode": "let finalResponse = {}\n\n// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  finalResponse = {...finalResponse, ...item.json }\n}\nreturn {...finalResponse};"
      },
      "id": "15ffdac4-1a6c-42c2-96c0-24cf732a1016",
      "name": "Code in JavaScript",
      "type": "n8n-nodes-base.code",
      "position": [
        2624,
        208
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 1,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "task-execution-condition",
              "operator": {
                "type": "number",
                "operation": "equals"
              },
              "leftValue": "={{ $json.readyTasks.length }}",
              "rightValue": 0
            }
          ]
        },
        "options": {}
      },
      "id": "777b8fb8-5da2-47b9-b837-505ed1262aaf",
      "name": "Check No Pending Tasks",
      "type": "n8n-nodes-base.if",
      "position": [
        400,
        144
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Collect all completed task results for final response generation\nconst taskRegistry = $input.item.json.taskRegistry;\nconst completedTasks = $input.item.json.completedTasks;\n\nconst taskResults = [];\nfor (const taskId of completedTasks) {\n  const task = taskRegistry[taskId];\n  if (task && task.status === 'success') {\n    taskResults.push({\n      task_description: task.task_description,\n      task_input: task.task_input,\n      task_tool: task.tool,\n      task_output: task.output,\n      task_status: task.status,\n      task_id: taskId\n    });\n  }\n}\n\nreturn {\n  taskResults,\n  totalTasksCompleted: completedTasks.length,\n  allTasksCompleted: true\n};"
      },
      "id": "54d2cefb-c9a2-45ff-a6f2-2d3aca6feaf7",
      "name": "Prepare Final Results",
      "type": "n8n-nodes-base.code",
      "position": [
        2096,
        128
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "b241d1dc-9052-4a92-b6e6-11a6924231a8",
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        0,
        0
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "model": "Qwen2.5:latest",
        "options": {
          "temperature": 0
        }
      },
      "id": "ad66b457-8946-4b09-aa46-f94e4cd25bea",
      "name": "qwen3",
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "position": [
        656,
        688
      ],
      "typeVersion": 1,
      "credentials": {
        "ollamaApi": {
          "id": "KLoaICSBpFR345xi",
          "name": "host.docker.internal"
        }
      }
    }
  ],
  "pinData": {
    "Start": [
      {
        "json": {
          "success": true,
          "chatInput": {
            "action": "sendMessage",
            "chatInput": "add numbers 3 and 5 and then encrypt answer before returning",
            "sessionId": "c26a80ddbae849bf8a500db8975814d2"
          },
          "task_plan": {
            "tasks": [
              {
                "task_id": "task_1",
                "tool": "add",
                "task_description": "Add numbers 3 and 5 together",
                "params": {
                  "a": 3,
                  "b": 5
                },
                "dependencies": []
              },
              {
                "task_id": "task_2",
                "tool": "encrypt",
                "task_description": "Encode the sum of 3 and 5 as a base64 string",
                "params": {
                  "text": {
                    "$ref": "#/tasks/0/results"
                  }
                },
                "dependencies": [
                  "task_1"
                ]
              }
            ]
          },
          "validation": {
            "tasks_count": 2,
            "tools_used": [
              "add",
              "encrypt"
            ],
            "total_params": 3,
            "has_dependencies": true,
            "warnings": [],
            "task_details": [
              {
                "task_id": "task_1",
                "tool": "add",
                "status": "valid",
                "required_params": [
                  "params"
                ],
                "provided_params": [
                  "a",
                  "b"
                ],
                "dependency_count": 0
              },
              {
                "task_id": "task_2",
                "tool": "encrypt",
                "status": "valid",
                "required_params": [
                  "params"
                ],
                "provided_params": [
                  "text"
                ],
                "dependency_count": 1
              }
            ]
          }
        }
      }
    ]
  },
  "connections": {
    "Merge": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start": {
      "main": [
        [
          {
            "node": "Task Dependency Resolver",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "qwen3": {
      "ai_languageModel": [
        [
          {
            "node": "Task Executor Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Check More Tasks": {
      "main": [
        [
          {
            "node": "Check No Pending Tasks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Final Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Task Results": {
      "main": [
        [
          {
            "node": "Update Task Registry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Ready Task": {
      "main": [
        [
          {
            "node": "Task Executor Agent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Task Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Task Result Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Task Executor Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Task Executor Agent": {
      "main": [
        [
          {
            "node": "Merge Task Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Task Registry": {
      "main": [
        [
          {
            "node": "Check More Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Final Results": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Check No Pending Tasks": {
      "main": [
        [
          {
            "node": "Prepare Final Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Ready Task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Task Dependency Resolver": {
      "main": [
        [
          {
            "node": "Check No Pending Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MCP Available Tools Client": {
      "ai_tool": [
        [
          {
            "node": "Task Executor Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f09fed0f-6695-47df-9270-cc759223eed8",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "45c417bac78415cc82936bcd15e18b8c6e14faf1263d26de9f0ef5352823a723"
  },
  "id": "UtC2ATWAFbknsBRR",
  "tags": []
}